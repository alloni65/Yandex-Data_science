#!/usr/bin/env python
# coding: utf-8

# <div style="border:solid green 2px; padding: 20px">
# <b>Никита, привет!</b>
# 
#     
# Меня зовут Лина, я буду проверять твой проект. Предлагаю общаться на «ты», но если это не удобно, дай мне знать и мы передем на "вы". 
# 
# Моя цель — сделать твой проект еще лучше!
# 
# Ниже ты найдешь мои комментарии - пожалуйста, не удаляй их, они будут особенно полезны для нашей работы в случае повторной проверки проекта. 
#     
# Я буду испoльзовать следующую цветовую разметку:
# <div class="alert alert-success">
# <b>✅ Комментарий ревьюера: </b> Так выделены комментарии, если решение на отдельном шаге является полностью правильным.</div>
#     
# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера:  </b> Так выделены небольшие замечания, либо рекоммендации к улучшению. Исправлять их не обязательно. Буду писать их, когда решение на отдельном шаге станет еще лучше, если внести небольшие коррективы.
# 
# </div>
# 
# <div class="alert alert-danger">
# <b>❌ Комментарий ревьюера: </b> Так выделены самые важные замечания. Без их отработки проект не будет принят. </div>
# 
# Если ты что-то меняешь в проекте или отвечаешь на мои комменатри — пиши об этом. Мне будет легче отследить изменения, если ты выделишь свои комментарии:
# <div class="alert alert-info"> <b>Комментарий студента:</b> Например, вот так.</div>
# 
# Всё это поможет выполнить повторную проверку твоего проекта оперативнее.

# # Исследование надежности заемщиков
# 

# Во второй части проекта вы выполните шаги 3 и 4. Их вручную проверит ревьюер.
# Чтобы вам не пришлось писать код заново для шагов 1 и 2, мы добавили авторские решения в ячейки с кодом. 
# 
# 

# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера v1: </b> 
#     
# Несмотря на то, что первая часть проекта проверяется автоматизрованно, дам по ней пару советов, они пригодятся тебе в следующих проектах. 
# 
# **Их отработка сейчас необязательна**.
# 
# - После названия обязательно нужно добавить цели исследования, описание данных и план работы.   
# - Каждый шаг работы стоит завершать кратким выводом: что было сделано, какие результаты получены.
# 
# Ты можешь воспользоваться методичкой по оформлению проектов. Ее можно найти в блоке курса: `Полезные инструкции для учёбы - Оформление проекта - Рекомендации по выполнению проектов`
# 
#  </div>

# ## Откройте таблицу и изучите общую информацию о данных

# **Задание 1. Импортируйте библиотеку pandas. Считайте данные из csv-файла в датафрейм и сохраните в переменную `data`. Путь к файлу:**
# 
# `/datasets/data.csv`

# In[2]:


import pandas as pd

try:
    data = pd.read_csv('/datasets/data.csv')
except:
    data = pd.read_csv('https://code.s3.yandex.net/datasets/data.csv')


# **Задание 2. Выведите первые 20 строчек датафрейма `data` на экран.**

# In[3]:


data.head(20)


# **Задание 3. Выведите основную информацию о датафрейме с помощью метода `info()`.**

# In[4]:


data.info()


# ## Предобработка данных

# ### Удаление пропусков

# **Задание 4. Выведите количество пропущенных значений для каждого столбца. Используйте комбинацию двух методов.**

# In[5]:


data.isna().sum()


# **Задание 5. В двух столбцах есть пропущенные значения. Один из них — `days_employed`. Пропуски в этом столбце вы обработаете на следующем этапе. Другой столбец с пропущенными значениями — `total_income` — хранит данные о доходах. На сумму дохода сильнее всего влияет тип занятости, поэтому заполнить пропуски в этом столбце нужно медианным значением по каждому типу из столбца `income_type`. Например, у человека с типом занятости `сотрудник` пропуск в столбце `total_income` должен быть заполнен медианным доходом среди всех записей с тем же типом.**

# In[6]:


for t in data['income_type'].unique():
    data.loc[(data['income_type'] == t) & (data['total_income'].isna()), 'total_income'] =     data.loc[(data['income_type'] == t), 'total_income'].median()


# ### Обработка аномальных значений

# **Задание 6. В данных могут встречаться артефакты (аномалии) — значения, которые не отражают действительность и появились по какой-то ошибке. таким артефактом будет отрицательное количество дней трудового стажа в столбце `days_employed`. Для реальных данных это нормально. Обработайте значения в этом столбце: замените все отрицательные значения положительными с помощью метода `abs()`.**

# In[6]:


data['days_employed'] = data['days_employed'].abs()


# **Задание 7. Для каждого типа занятости выведите медианное значение трудового стажа `days_employed` в днях.**

# In[7]:


data.groupby('income_type')['days_employed'].agg('median')


# У двух типов (безработные и пенсионеры) получатся аномально большие значения. Исправить такие значения сложно, поэтому оставьте их как есть. Тем более этот столбец не понадобится вам для исследования.

# **Задание 8. Выведите перечень уникальных значений столбца `children`.**

# In[8]:


data['children'].unique()


# **Задание 9. В столбце `children` есть два аномальных значения. Удалите строки, в которых встречаются такие аномальные значения из датафрейма `data`.**

# In[9]:


data = data[(data['children'] != -1) & (data['children'] != 20)]


# **Задание 10. Ещё раз выведите перечень уникальных значений столбца `children`, чтобы убедиться, что артефакты удалены.**

# In[10]:


data['children'].unique()


# ### Удаление пропусков (продолжение)

# **Задание 11. Заполните пропуски в столбце `days_employed` медианными значениями по каждого типа занятости `income_type`.**

# In[11]:


for t in data['income_type'].unique():
    data.loc[(data['income_type'] == t) & (data['days_employed'].isna()), 'days_employed'] =     data.loc[(data['income_type'] == t), 'days_employed'].median()


# **Задание 12. Убедитесь, что все пропуски заполнены. Проверьте себя и ещё раз выведите количество пропущенных значений для каждого столбца с помощью двух методов.**

# In[12]:


data.isna().sum()


# ### Изменение типов данных

# **Задание 13. Замените вещественный тип данных в столбце `total_income` на целочисленный с помощью метода `astype()`.**

# In[13]:


data['total_income'] = data['total_income'].astype(int)


# ### Обработка дубликатов

# **Задание 14. Обработайте неявные дубликаты в столбце `education`. В этом столбце есть одни и те же значения, но записанные по-разному: с использованием заглавных и строчных букв. Приведите их к нижнему регистру. Проверьте остальные столбцы.**

# In[14]:


data['education'] = data['education'].str.lower()


# **Задание 15. Выведите на экран количество строк-дубликатов в данных. Если такие строки присутствуют, удалите их.**

# In[15]:


data.duplicated().sum()


# In[16]:


data = data.drop_duplicates()


# ### Категоризация данных

# **Задание 16. На основании диапазонов, указанных ниже, создайте в датафрейме `data` столбец `total_income_category` с категориями:**
# 
# - 0–30000 — `'E'`;
# - 30001–50000 — `'D'`;
# - 50001–200000 — `'C'`;
# - 200001–1000000 — `'B'`;
# - 1000001 и выше — `'A'`.
# 
# 
# **Например, кредитополучателю с доходом 25000 нужно назначить категорию `'E'`, а клиенту, получающему 235000, — `'B'`. Используйте собственную функцию с именем `categorize_income()` и метод `apply()`.**

# In[17]:


def categorize_income(income):
    try:
        if 0 <= income <= 30000:
            return 'E'
        elif 30001 <= income <= 50000:
            return 'D'
        elif 50001 <= income <= 200000:
            return 'C'
        elif 200001 <= income <= 1000000:
            return 'B'
        elif income >= 1000001:
            return 'A'
    except:
        pass


# In[18]:


data['total_income_category'] = data['total_income'].apply(categorize_income)


# **Задание 17. Выведите на экран перечень уникальных целей взятия кредита из столбца `purpose`.**

# In[19]:


data['purpose'].unique()


# **Задание 18. Создайте функцию, которая на основании данных из столбца `purpose` сформирует новый столбец `purpose_category`, в который войдут следующие категории:**
# 
# - `'операции с автомобилем'`,
# - `'операции с недвижимостью'`,
# - `'проведение свадьбы'`,
# - `'получение образования'`.
# 
# **Например, если в столбце `purpose` находится подстрока `'на покупку автомобиля'`, то в столбце `purpose_category` должна появиться строка `'операции с автомобилем'`.**
# 
# **Используйте собственную функцию с именем `categorize_purpose()` и метод `apply()`. Изучите данные в столбце `purpose` и определите, какие подстроки помогут вам правильно определить категорию.**

# In[20]:


def categorize_purpose(row):
    try:
        if 'автом' in row:
            return 'операции с автомобилем'
        elif 'жил' in row or 'недвиж' in row:
            return 'операции с недвижимостью'
        elif 'свад' in row:
            return 'проведение свадьбы'
        elif 'образов' in row:
            return 'получение образования'
    except:
        return 'нет категории'


# In[21]:


data['purpose_category'] = data['purpose'].apply(categorize_purpose)


# ### Шаг 3. Исследуйте данные и ответьте на вопросы

# #### 3.1 Есть ли зависимость между количеством детей и возвратом кредита в срок?

# In[22]:


data_grouped = data.groupby('children').agg({'debt':'sum'})
data_grouped['amount'] = data.value_counts('children')
data_grouped['ratio_household'] = data_grouped['amount'] / data_grouped['amount'].sum()
data_grouped['ratio_debt'] = data_grouped['debt'] / data_grouped['amount']
data_grouped


# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера: v1 </b> 
#     
# Для более аккуратного вывода таблиц в юпитере попробуй использовать `display()` вместо `print()`.
#     
# А если вывод датафрейма или переменной на последней строке ячейки, то вообще ничего не надо. 
# </div>

# <div class="alert alert-success">
# <b>✅ Комментарий ревьюера v2: </b> 
# 
# 👍
# </div>

# **Вывод:** Если категории семей с 4 и 5 детьми исключить из данного исследования ввиду их незначительной доли, то мы можем заметить незначительную положительную корреляцию между ростом количества детей и наличием незакрытого кредитного бремени. Наличие детей в семье делает клиента менее платежеспособным.

# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера: v1 </b> 
#     
# Здесь лучше пояснить, какую именно корреляцию мы видим: прямую или обратную?
# </div>

# <div class="alert alert-success">
# <b>✅ Комментарий ревьюера v2: </b> 
# 
# Да, так точнее!)
# </div>

# #### 3.2 Есть ли зависимость между семейным положением и возвратом кредита в срок?

# In[23]:


data_grouped = data.groupby('family_status').agg({'debt':'sum'})
data_grouped['amount'] = data.value_counts('family_status')
data_grouped['ratio_household'] = data_grouped['amount'] / data_grouped['amount'].sum()
data_grouped['ratio_debt'] = data_grouped['debt'] / data_grouped['amount']
data_grouped.sort_values(by = 'ratio_debt', ascending = False)


# <div class="alert alert-success">
# <b>✅ Комментарий ревьюера v1: </b> 
# 
# Таблица верная!
#     
# </div>

# **Вывод:** Люди, которые еще не никогда не расписывались в ЗАГСе, судя по статистике, хуже возвращают кредиты. Узаконивание своих чувств делает людей более дисциплинированными.

# <div class="alert alert-success">
# <b>✅ Комментарий ревьюера v1: </b> 
# 
# Абсолютно согласна!
#     
# </div>

# #### 3.3 Есть ли зависимость между уровнем дохода и возвратом кредита в срок?

# In[24]:


data_grouped = data.groupby('total_income_category').agg({'debt':'sum'})
data_grouped['amount'] = data.value_counts('total_income_category')
data_grouped['ratio_household'] = data_grouped['amount'] / data_grouped['amount'].sum()
data_grouped['ratio_debt'] = data_grouped['debt'] / data_grouped['amount']
print(data_grouped)


# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера v1: </b> 
# 
# Хорошо бы добавить расшифровку категорий в таблицу. </div>
# 

# **Вывод:** Аналогично с выводом первой задачи, категории уровня заработка A и Е, доля которых составляет менее 1%, учтены не будут. Анализируя оставшиеся категории, можно выделить В и С (50 001 - 200 000 и 200 001 - 1 000 000) как самые не дисциплинированные категории.

# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера v1: </b> 
# 
# Здесь можно даже только B и С сравнить и сказать, что доля должников падает с ростом дохода.
# </div>

# #### 3.4 Как разные цели кредита влияют на его возврат в срок?

# In[25]:


data_grouped = data.groupby('purpose_category').agg({'debt':'sum'})
data_grouped['amount'] = data.value_counts('purpose_category')
data_grouped['ratio_household'] = data_grouped['amount'] / data_grouped['amount'].sum()
data_grouped['ratio_debt'] = data_grouped['debt'] / data_grouped['amount']
print(data_grouped)


# **Вывод:** Самые стабильные выплаты производятся гражданами, кто решил посотрудничать с банком для покупки недвижимости. Пъедестал просроченных выплат делят люди, которые взяли кредит для покупки авто и получения образования. 

# <div class="alert alert-success">
# <b>✅ Комментарий ревьюера v1: </b>
#  
# Все верно. С таблицей и выводом согласна.</div>

# #### 3.5 Приведите возможные причины появления пропусков в исходных данных.

# *Ответ:* Предполагаю, что причин появления пропусков может быть несколько. Первый и основной - наличие в графе "цели кредита" категории "получение образования", так как кредит могли выдать студенту, у которого еще нет источника дохода и, как следствие, опыта работы. Также, есть вероятность человеческого фактора - сотрудники банка не заполняли эти данные по каким-либо причинам.

# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера v1:</b> 
# 
# Как думаешь,  кроме человеческого фактора (кто-то не ввел данные: забыли или их просто нет), что еще может стать причиной пропусков? </div>
# 

# #### 3.6 Объясните, почему заполнить пропуски медианным значением — лучшее решение для количественных переменных.

# *Ответ:* Медианное значение является лучшим решением, так как такое значение не сильно меняется при добавлении новых данных, в отличе от среднего значения. Удалять строки с пропусками еще более критично, так как это решение может сильно сказаться на будущих подсчетах и выводах.

# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера v1:</b> 
# 
# Поясни, пожалуйста, почему именно медианное значение не сильно меняется? И как ведет себя медиана и среднее при наличии сильных выбросов в данных? </div>
# 

# ### Шаг 4: общий вывод.

# Был получен запрос от заказчика на исследование данных о заемщиках с целью поиска взаимосвязи дисциплинированности выплат и различных факторов, которые могут влиять на платежеспособность.
# 
# Данные, полученные от заказчика, оказались с пропусками, что, по предварительной оценке, является следствием профиля кредитора: некоторые заемщики не обладают теми свойствами, по которым банк категоризирует клиента. В связи с чем, для наиболее приближенного к реальности результата, было принято решение дать таким заемщикам медианные значения по категориям, в которых находились пропуски.
# 
# По итогам исследования, были сделаны следующие выводы по заданным вопросам:
# 1. Люди, которые еще не никогда не расписывались в ЗАГСе, судя по статистике, хуже возвращают кредиты. Узаконивание своих чувств делает людей более дисциплинированными (не женаты/замужем - 9.7%, гражданский брак - 9.3%)
# 2. Если категории семей с 4 и 5 детьми исключить из данного исследования ввиду их незначительной доли, то мы можем заметить незначительную корреляцию между ростом количества детей и наличием незакрытого кредитного бремени. Наименее дисциплинированными являются граждане с 2 детьми (9.5%)
# 

# <div class="alert alert-warning">
# <b>⚠️ Комментарий ревьюера v1:</b> 
# 
# Отличный вывод!
#     
# Но лучше добавить все выявленные зависимости и инсайты в каждом пункте исследования. </div>

# <div style="border:solid green 2px; padding: 20px">
#  
# Никита, у тебя получилась отличная работа! Ты отлично справился с построением таблиц.
#     
# Критических замечаний нет.
#     
# Я готова принять твой проект. Возвращаю его тебе на случай, если у тебя остались какие-то вопросы, или есть желание доработать желтые комментарии. </div>

# <div style="border:solid green 2px; padding: 20px">
#  
# Никита, отличная работа! Проект принят. </div>
